/**********************************************************************/
/* Copyright 2014 RCF                                                 */ 
/*                                                                    */
/* Licensed under the Apache License, Version 2.0 (the "License");    */
/* you may not use this file except in compliance with the License.   */
/* You may obtain a copy of the License at                            */
/*                                                                    */
/*     http://www.apache.org/licenses/LICENSE-2.0                     */
/*                                                                    */
/* Unless required by applicable law or agreed to in writing,         */
/* software distributed under the License is distributed on an        */
/* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,       */
/* either express or implied.                                         */
/* See the License for the specific language governing permissions    */
/* and limitations under the License.                                 */
/**********************************************************************/

// Default Libraries
#include <vector>
#include <iostream>

// Libraries
//#include "Stk.hpp"
#include "Text.hpp"
#include "Number.hpp"
#include "Address.hpp"
#include "Stackable.hpp"
#include "Fibonacci.hpp"
using namespace stk;

/**
 * <b>Parser for program sample/fibonacci.asm.</b>
 * This file is automatically 
 * generated by parser.pl
 * @author parser.pl
 */
vm::Prog parser::quark::upload_Fibonacci()
{
    using namespace vm;
    vm::Prog PROG;

    // Address variables
    Stackable_ptr adr1 { new Address { 0 } };
    Stackable_ptr adr2 { new Address { 1 } };
    Stackable_ptr adr3 { new Address { 2 } };

    // Numerical variables
    Stackable_ptr num1 { new Number { 1 } };
    Stackable_ptr num2 { new Number { 10 } };
    Stackable_ptr num3 { new Number { 0 } };

    // Textual variables
    Stackable_ptr msg1 { new stk::Text { "LOOP" } };

    PROG.push_back( vm::Command { Command::Opcode::PUSH, num1         });
    PROG.push_back( vm::Command { Command::Opcode::DUP                });
    PROG.push_back( vm::Command { Command::Opcode::STO , adr1         });
    PROG.push_back( vm::Command { Command::Opcode::STO , adr2         });
    PROG.push_back( vm::Command { Command::Opcode::PUSH, num2         });
    PROG.push_back( vm::Command { Command::Opcode::STO , adr3         });
    PROG.push_back( vm::Command { Command::Opcode::RCL , adr1, "LOOP" });
    PROG.push_back( vm::Command { Command::Opcode::RCL , adr2         });
    PROG.push_back( vm::Command { Command::Opcode::DUP                });
    PROG.push_back( vm::Command { Command::Opcode::STO , adr1         });
    PROG.push_back( vm::Command { Command::Opcode::ADD                });
    PROG.push_back( vm::Command { Command::Opcode::DUP                });
    PROG.push_back( vm::Command { Command::Opcode::STO , adr2         });
    PROG.push_back( vm::Command { Command::Opcode::PRN                });
    PROG.push_back( vm::Command { Command::Opcode::RCL , adr3         });
    PROG.push_back( vm::Command { Command::Opcode::PUSH, num1         });
    PROG.push_back( vm::Command { Command::Opcode::SUB                });
    PROG.push_back( vm::Command { Command::Opcode::DUP                });
    PROG.push_back( vm::Command { Command::Opcode::STO , adr3         });
    PROG.push_back( vm::Command { Command::Opcode::PUSH, num3         });
    PROG.push_back( vm::Command { Command::Opcode::EQ                 });
    PROG.push_back( vm::Command { Command::Opcode::JIF , msg1         });
    PROG.push_back( vm::Command { Command::Opcode::END                });

    return PROG;
}

